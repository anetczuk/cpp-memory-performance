# Measuring memory performance

Project presents results of various memory benchmarks.
Benchmarks are done for processor cache (L1, L2, L3) and for RAM memory of code generated by gcc and clang compilers for Intel and ARM devices.


## Table of content

1. [Experimets explanation](doc/README.md#experiments_exp)
2. [Environments under benchmark](doc/README.md#environments)
3. [Results](doc/README.md#results)
    1. [Measurements](doc/measurements/README.md#top)
    2. [Performance cost of Virtual Box](doc/comparison/README.md#vbox_perform)
    3. [Comparison of compilers](doc/comparison/README.md#compilers)
        - [Loop unrolling](doc/comparison/README.md#loop_unrolling)
    4. [Cache influence on i7](doc/comparison/README.md#i7_cache)
        - [Impact on multiple threads and processes](doc/comparison/README.md#i7_cache_multi)
    5. [Cache influence on Raspberry Pi](doc/comparison/README.md#rpi_cache)
        - [Impact on multiple threads and processes](doc/comparison/README.md#rpi_cache_multi)
    6. [Best compiler](doc/comparison/README.md#best_compiler)
4. [TL;DR](#tldr)
5. [Compilation and execution](#compilation)
6. [Requirements](#requirements)
7. [Techniques usage examples](#techniques)
8. [References](#references)


## <a name="tldr"></a> TL;DR

* i7: *L2* cache is marginally faster than *L3* ([plot](doc/comparison/i7/vector_st_data_plot.png))
* RPi: there is no difference between *L1* and *L2* cache ([plot](doc/comparison/rpi3/vector_st_data_plot.png))
* there is no difference in memory access timing between multi-threaded and multi-processed benchmarks
* VirtualBox utilizes *CPU* cache as efficient as host system ([plot](doc/comparison/i7-i7_vbox_1/gcc-clang/vector_st_data_plot.png))
* access time to *RAM* under VirtualBox is up to two times longer than under host ([plot](doc/comparison/i7-i7_vbox_1/gcc-clang/cllist_st_data_plot.png))
* for general use *clang 9.0.0* is advised to use instead of *gcc 7.4.0* ([comparison](doc/comparison/README.md#best_compiler))
* fastest code is generated by *gcc 7.4.0* with loop unrolling ([comparison](doc/comparison/README.md#best_compiler))


## <a name="compilation"></a> Compilation and execution

To compile all exercises execute following sequence:
1. create build directory
2. go to build directory
3. configure: ```cmake -D CMAKE_BUILD_TYPE=Release /abs/path/to/src```
    * use CMake's ```LOOP_UNROLL``` option to activate unrolling
4. compile: ```make```
5. (optional) run tests by: ```ctest```
6. execute benchmarks, for example: ```./mem_performance/plot_all.sh --maxmem 1.6G```
7. examine results stored in directory ```./mem_performance/data```

Configuration can be done also by one of preconfigured scripts located in *configure* direcotry.


## Requirements

- C++ 14 standard supporting compiler
- CMake 3.1.1 or higher


## <a name="techniques"></a>Techniques usage examples

- inclusion of cmake's modules
- *gtest* integration as cmake external project
- configuration of code coverage for *gcc*
- configuration of *clang* sanitizer
- preparing data and plotting with *gnuplot*


## References

- *Googletest* testing framework [repository](https://github.com/google/googletest)

